---
layout:     post
title:      "Borrow me ðŸ¦€"
date:       2024-04-10
summary:    A look into Rust ownership/borrow system
categories: rust memory swe systems
---

Outline:
- Intro
- Premises: (im)mutability,  Clone vs. Copy, & operator
- The OB system
  - Owner (read, write)
  - Borrower (read, write)
  - 

The ownership/borrow system is the core component that allows Rust to not have a garbage collector and, at the same time, protect memory.
Before to look into that though, it is important to clear out essential concepts that will make easier to understand the system and avoid common pitfalls while programming.

## Premises

### 1. Variables are, by default, immutable

That's it. `let x = 10` makes `x` immutable and will always have value `10` (as long as it is in scope).

### 2. Variables can be made mutable

`let mut x = 1` allows to change the value later in the code (as long as it is in scope).

### 3. Data types possess the `Clone` trait and (some of them) the `Copy` trait too

The `Clone` trait is a functionality that allows to _explicitly_ duplicate an object.\
**All** data types have the `Clone` trait.

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i.clone(); // function defined in `Clone`
    println!("{}", g);
    println!("{}", i);
}
```
    Output:
    4.5
    4.5

Here `i` and `g` are two distinct instances of type `f32` containing the value `4.5`.

The `Copy` trait is a functionality that allows to _implicitly_ duplicate an object.
Numbers, characters, booleans possess the `Clone` and `Copy` traits. The same holds for arrays and tuples if the contain types with `Copy` trait.

By definition, `Copy` is a subtrait of `Clone`. What does this mean?

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i; // the equal sign "activates" Copy
    println!("{}", g);
    println!("{}", i);
}
```
    Output:
    4.5
    4.5

`clone()` and the assignment operator `=` do the same thing as long as a type has the `Copy` trait: this is the reason why you never see `clone()` used to copy numeric or boolean primitives.

But what happens if `=` is used with types who only have the `Clone` trait?

```rust
fn main() {
    let i: Vec<i32> = vec![1, 2, 3];
    let g = i; // something happens
    println!("{:?}", g);
    println!("{:?}", i); // error
}
```
The last `println!` throws an error at compile time:

![](/images/posts/borrow_me/bm_compile_error.png)

### 4. The ampersand operator `&`

When used in front of variables, `&` references them, that is, it contains information to find the value in the memory. For example, `&String` has information
on where the `String` starts in memory, its length, and its capacity:

```rust
fn main() {
    let mut i: String = String::with_capacity(15);
    let s = "I am a string";
    for c in s.chars() {
        i.push(c);       // fill String i
    }
    let t = &i;          // reference
    println!("Memory address: {:?}", t.as_ptr()); 
    println!("Length: {}", t.len());
    println!("Capacity: {}", t.capacity());
}
```

    Output:
    Memory address: 0x55d9c2f8fad0
    Length: 13
    Capacity: 15


## The ownership/borrow system

In general, data are owned by:
1. Variables: in `let string = String::from("Hello")`, `string` owns `"Hello"`
2. Values: in `let vector = vec![vec![1, 2], vec![3, 4]]`, `vector` owns values `vec![1, 2]` and `vec![3, 4]`; value `vec![1, 2]` owns `1` and `2`; value `vec![3, 4]` owns `3` and `4`

This can lead to effects that are, at first, surprising:

```rust
fn main() {
    let vector = vec![vec![1,2],vec![3,2]];
    let number = vector[0][0];
    println!("{}", vector[0][0]);
}
```
    Output:
    1

The variable `vector` does not have a `Copy` trait, and neither its elements (vectors). But those contain integers: this is why the compiler does not complain
