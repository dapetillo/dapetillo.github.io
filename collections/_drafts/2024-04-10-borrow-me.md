---
layout:     post
title:      "A take on the Ownership-Borrow world of Rust ðŸ¦€"
date:       2024-04-10
summary:    A look into Rust ownership/borrow system
categories: rust memory swe systems
---

# Useful resources (to move under reference before publish)
- [https://smallcultfollowing.com/babysteps/blog/2014/05/13/focusing-on-ownership/](https://smallcultfollowing.com/babysteps/blog/2014/05/13/focusing-on-ownership/)
- [https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html](https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html)


# Intro

Few weeks ago I started learning Rust. It is a fascinating language and, coming from Python, its Ownership-Borrow framework was novel to me. So novel, I obsessed on it for some days - maybe a week, I admit - as I tried to crack it open and make it mine.
I think I partially succeded, also thanks to writing this post. And I hope it can help other people too!

## Essential concepts

There are some essential facts that are required to understand why and how Ownership works the way it does.

### 0. It's not only about memory safety

You have probably heard many times that the Ownership framework of Rust is at the core of its memory-safe feature. But it is much more. Ownership is also about control and clarity: you (must) decide how long data can be accessed, how they interact with each other and if external interfaces can change them, forcing you to reason about your software.

### 1. Variables are, by default, immutable
When binding a value to a variable, it cannot be changed anymore:
```rust
fn main(){
    let x: i32 = 10;
    x = 5; // ERROR
}
```
The `let` keyword binds `x` to `10` until it is in scope.


### 2. Variables can be made mutable
The `mut` keyword tells the compiler that the value to a variable can be changed:
```rust
fn main(){
    let mut x: i32 = 10; 
    x = 5; // OK
    x = 3; // also OK
}
```
The variable `x` can hold any 32-bit integer as long as it is in scope. 
 ~~`let mut x = 1` allows to change the value later in the code (as long as it is in scope).~~

### 3. Data types possess the `Clone` trait and (some of them) the `Copy` trait too

A trait is a functionality used to tell how a type should behave. `Clone` allows to _explicitly_ duplicate an object:

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i.clone(); // function defined in `Clone`
    println!("I am i: {}", i);
    println!("I am g:{}", g);
}
```
    Output:
    4.5
    4.5

Here `i` and `g` are two distinct instances of type `f32` containing the value `4.5`. **All** types have `Clone`.

`Copy` is a subtrait of `Clone` and allows to _implicitly_ duplicate an object using the assignment operator `=`:

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i; // the equal sign "activates" Copy
    println!("{}", g);
    println!("{}", i);
}
```
    Output:
    4.5
    4.5

Here `clone()` and the assignment operator `=` do the same thing as long as a type has the `Copy` trait too.
Numbers, characters and booleans possess the both traits. The same is true for arrays and tuples contaiting types with `Copy`: this is the reason why you never see `clone()` being used with them.

But what happens if `=` is used with types who only have `Clone`?

```rust
fn main() {
    let vector1: Vec<i32> = vec![1, 2, 3];
    let vector2 = vector1; // something happens
    println!("{:?}", vector2);
    println!("{:?}", vector1); // ERROR
}
```
The last `println!` throws an error at compile time:

![](/images/posts/borrow_me/bm_compile_error.png)

This is one of the first effects of the ownership/borrow system: the compiler says that we are trying to borrow `i` **after** we moved it. We will see later what this means.

### 4. The ampersand operator `&`

When used in front of variables, `&` references them, that is, it provides information used to access the value in memory. For example, `&String` has information
on where the `String` starts in memory, its length, and its capacity (aka maximum length possible):

```rust
fn main() {
    let mut i: String = String::with_capacity(15);
    let s = "I am a string";
    for c in s.chars() {
        i.push(c);       // fill String i
    }
    let t = &i;          // &String, reference
    println!("Memory address: {:p}", t); 
    println!("Length: {}", t.len());
    println!("Capacity: {}", t.capacity());
}
```

    Output:
    Memory address: 0x55d9c2f8fad0
    Length: 13
    Capacity: 15


## The Ownership-Borrowing mental model

Ownership and borrowing are the two cornerstones of Rust. While they apply to the language as a whole, they are just concepts - it is convenient to speak in these terms, but they do not **fully** relate with what happens under the hood. I think it's important to keep this in mind to better understand Rust.
Ownership can be defined as the initialization of a variable with a value, while borrowing the act of _temporarily_ getting access to such value. This might sound different from what the Rust book and other sources say, but it is really just it. The problem is how ownership and borrowing are established. Each one can, indeed, be unique or shared.

### Unique and shared ownership

Let's talk about unique ownership first. You already saw it in action:

```rust
fn main(){
    let integer = 5;
    let float = 12.3;
    let char_ = 'a';
    let array = ['a', 'b', 'c'];
    let vector = vec![3, 6, 9];
    let string = String::from("I am unique");
    // ...
}
```
Rust puts not only the values in memory, but also the info that binds them **uniquely** to their variables. This means, you cannot have more than one variable referring to the same value **and** the same space in memory. This is why example X and Y still work: even though `vector2` and `vector1` hold the same value, the space in memory is different because of Copy and Clone.
So what did happen in Example Z? The vector does not have a Copy trait, so the assignment operator cannot copy the value in another memory region and assign it to `vector2`. But the ownership must be unique, so the two variables cannot have access to the same memory at the same time: Rust will then transfer ownership from `vector1` to `vector2`. It means that the info that binds `vector1` to its value is now passed to `vector2`:

```rust
fn main() {
    let vector1: Vec<i32> = vec![1, 2, 3];
    let ptr_vector1 = vector1.as_ptr();
    let vector2 = vector1; // info transfer, e.g. pointers
    let ptr_vector2 = vector2.as_ptr();
    assert_eq!(ptr_vector1, ptr_vector2); // they are equal
}
```
Because of the transfer, `vector2` is bound to the value `vector1` was initialized with. What happens to `vector1`? Since it is not bounded to any value anymore, it lives in an undefined state. As a consequence, Rust stops any attempt to use it **by design**[^3].
So what if you want two or more variables holding the same value from the same memory?

This is where the shared ownership comes into play. There are basically two data structures that can be used to achive this, `Rc` and `Arc`, with the difference that the former is used in single threads code and the latter in multi-thread. I will give an example with `Rc`:

```rust
fn main(){
    let x = Rc::new(vec![1, 2, 3]);
    let y = Rc::clone(&x);
    assert_eq!(y.as_ptr(), x.as_ptr());
    println!("Vector from x: {:?}", x);
}
```
    Output:
    Vector from x: [1, 2, 3]

Do not be misled by `clone()`! x and y point to the same value and they are both owners: they can be independently used to read the same value, for example.

### Unique and shared borrowing

(############I played a bit with Rust to see if I One could arg What would happen if Going one step further, it is possible to show how `vector1` is in an undefined state:

```rust
#![feature(vec_into_raw_parts)]
fn main(){
    let vector1: Vec<i32> = vec![1, 2, 3];
    let ptr_vector1 = vector1.as_ptr() as *mut i32;
    let len1 = vector1.len();
    let cap1 = vector1.capacity();
    println!("Pointer of vector1: {:p}", ptr_vector1);
    
    let mut vector2 = vector1;
    println!("Pointer of vector2: {:p}", vector2.as_ptr());

    let mut vector1: Vec<i32> = unsafe {
        Vec::from_raw_parts(ptr_vector1, len1, cap1)
    };
    
    vector1.push(8);
    vector2.push(10);
    assert_eq!(vector1, vector2);
    println!("{:?}", vector2);
    println!("{:?}", vector1);
```
    Output:


#############)
An ownership is created when, for example, a variable is bound to a value for the first time


, a relationship is formed A simplified definition of ownership is that "a variable is the sole responsible of the value it is bound to".
What this means is that once a value has an owner, only some actions are permitted  

```rust
fn main(){
    let string = String::from("Hello"); 
    let raw_pointer = string.as_ptr();
    
    let deref_value = *raw_pointer; //ERROR
}
```
When we get the pointer 
The variables `string` and `number` have the **sole ownership** over their values, `Hello` and `100`, respectively. No one else can have access to them but their owners.

In borrowing, the owners **temporarily** surrender their ownership to others:

```rust

fn borrowing_string_and_number(b1: &String, b2: &i32){
    println!("{} World!", b1);
    println!("{} + 1: {}", b2, b2 + 1);
} 


fn main(){
    let string = String::from("Hello");
    let number = 100;

    // string and number surrender ownership
    borrowing_string_and_number(&string, &number); 
    // string and number have ownership back


}
```

### Unique access
In Rust, a variable can have exclusive access to a value:
Unique access means that a variable has exclusive access to a value.

### Ownership 
It means that an owner $$A$$ owns $$B$$, and that $$A$$ is the **sole responsible** of deciding what happens to $$B$$ and itself.
`let string = String::from("Hello")` means exactly that: `string` owns `Hello` and manages it.

### Actions
Let's say we have the owner $$A$$, the owned value $$B$$ and a third object $$C$$ yet to be defined.
What are the significant actions that $$A$$ applies on $$B$$ and itself, and how those reflect on another object $$C$$?
The table below gives an overview of the actions:

| Action | Applies to   | Affects |
| ------ | ------------ | ------- |
| read   | $$B$$        |         |
| write  | $$B$$        |         |
| copy   | $$B$$        | $$C$$   |
| clone  | $$B$$        | $$C$$   |
| move   | $$A$$, $$B$$ | $$C$$   |
| borrow | $$A$$, $$B$$ | $$C$$   |
| drop   | $$A$$, $$B$$ |         |


Most of the actions are obvious from the premises, and two are critical in Rust: move and borrow.

Move transfers ownership, meaning that a third object $$C$$ becomes the sole owner of $$B$$, and $$A$$ cannot be used anymore[^1]:

```rust
fn main() {
    let string = String::from("Hello");
    let other_string = string; // string does not hold any value anymore
    println!("{}", other_string); // this prints fine
    // println!("{}", string); // if commented out, compiler complains
}
```


Borrow grants temporal access: $$A$$ allows a third object $$C$$ to access $$B$$ while still keeping ownership. Borrow is created using the reference operator `&` and it ends when the object borrowing is dropped:

```rust
fn main() {
    let string = String::from("Hello");
    let other_string = &string; // other_string has access to string
    println!("{}", other_string); // this prints fine
    // println!("{}", string); // this too
}
// main() ended, borrow is dropped
```

### Coherence

At any moment in time, actions on $$A$$, $$B$$ and related objects must be coherent to each other such that the program's behavior is never undefined.

Examples:

- $$A$$ and $$B$$ cannot be dropped while $$B$$ is still borrowed: what should the program return, if you try to read it?
    ```rust
    fn main() {
    let string = String::from("Hello");
    
    let t = &string; // borrow
    
    drop(string); // string dropped, what value holds t?
    println!("{}", t); // undefined behavior for t
    }
    ```

- $$B$$ cannot be changed while borrowed: a change in $$B$$ generally changes its location in memory, aka the reference. What would the old reference point to?
    ```rust
    fn main() {
        let mut vec = vec![1,2];

        let t = &vec;
        println!("Before push: {:?}", t.as_ptr());

        for l in 0..100000 {
        vec.push(l);
        }

        println!("After push: {:?}", vec.as_ptr());
    }
    ```
        Output:
        Before: 0x561ac43289d0
        After: 0x7fa742183010

    Because `t` holds an old reference, it's undefined what it points to:
    ```rust
    fn main() {
        let mut vec = vec![1,2];

        let t = &vec;        // 0x561ac43289d0
        for l in 0..100000 {
        vec.push(l);
        }                    // 0x7fa742183010

        println!("{:?}", t); // t does not refer to vec anymore
    }
    ```

- $$B$$




For example, it makes sense that once out of scope, the owner $$A$$ drops $$B$$ and itself, thus releasing memory:

```rust
fn main() {
    let string = String::from("Hello");
    // nothing else happening
}
```

    MIR Output:

    // WARNING: This output format is intended for human consumers only
    // and is subject to change without notice. Knock yourself out.
    fn main() -> () {
        let mut _0: ();
        let _1: std::string::String;
        scope 1 {
            debug string => _1;
        }

        bb0: {
            _1 = <String as From<&str>>::from(const "Hello") -> [return: bb1, unwind continue];
        }

        bb1: {
            drop(_1) -> [return: bb2, unwind continue];
        }

        bb2: {
            return;
        }
    }

If we look at the MIR, an intermediate compile-time step[^2], we see that the variable `string`, identified as `_1`, is owned the string "Hello" in the `bb0` block and dropped in `bb1`, just before going out of scope.


In general, variables have ownership over values: in `let string = String::from("Hello")`, the variable `string` has ownership over the value `"Hello"`.\
But values can also have ownership over other values, for example in case of complex data structures: in `let vector = vec![vec![1, 2], vec![3, 4]]`, the variable `vector` owns values `vec![1, 2]` and `vec![3, 4]`; value `vec![1, 2]` owns values `1` and `2`; value `vec![3, 4]` owns values `3` and `4`

This can lead to effects that are, at first, surprising:

```rust
fn main() {
    let vector = vec![vec![1,2],vec![3,2]];
    let number = vector[0][0];
    println!("{}", vector[0][0]);
}
```
    Output:
    1

The variable `vector` does not have a `Copy` trait, and neither its vector elements. Why no error is thrown? Because `vector[0][0]` is an integer, and integers have the `Copy` trait.



[^1]: it actually becomes uninitialized. You can assign it any value matching its type.
[^2]: for more details, [see the MIR article on Rust Blog](https://blog.rust-lang.org/2016/04/19/MIR.html)
[^3]: you _can_ circumvent the problem and have two variables pointing to the same value and memory, but it does not mean you _should_. 

| Action | Applies to   | Operator/Method         |
| ------ | ------------ | ----------------------- |
| read   | $$B$$        | general_method()        |
| write  | $$B$$        | `mut`, general_method() |
| copy   | $$B$$        | `=`                     |
| clone  | $$B$$        | `=`, `clone()`          |
| move   | $$A$$, $$B$$ | `=`                     |
| borrow | $$A$$, $$B$$ | `&`                     |
| drop   | $$A$$, $$B$$ | automatic, `drop()`     |