---
layout:     post
title:      "Borrow me ðŸ¦€"
date:       2024-04-10
summary:    A look into Rust ownership/borrow system
categories: rust memory swe systems
---


The ownership/borrow system is the core component that allows Rust to not have a garbage collector and, at the same time, protect memory.
Before to look into that though, it is important to clear out essential concepts that will make easier to understand the system and avoid common pitfalls while programming.

## Premises

### 1. Variables are, by default, immutable

That's it. `let x = 10` makes `x` immutable and will always have value `10` (as long as it is in scope).

### 2. Variables can be made mutable with `mut`

`let mut x = 1` allows to change the value later in the code (as long as it is in scope).

### 3. Data types possess the `Clone` trait and (some of them) the `Copy` trait too

The `Clone` trait is a functionality that allows to _explicitly_ duplicate an object.\
**All** data types have the `Clone` trait.

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i.clone(); // function defined in `Clone`
    println!("{}", g);
    println!("{}", i);
}
```
    Output:
    4.5
    4.5

Here `i` and `g` are two distinct instances of type `f32` containing the value `4.5`.

The `Copy` trait is a functionality that allows to _implicitly_ duplicate an object.
Numbers, characters, booleans possess the `Clone` and `Copy` traits. The same holds for arrays and tuples if the contain types with `Copy` trait.

By definition, `Copy` is a subtrait of `Clone`. What does this mean?

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i; // the equal sign "activates" Copy
    println!("{}", g);
    println!("{}", i);
}
```
    Output:
    4.5
    4.5

`clone()` and the assignment operator `=` do the same thing as long as a type has the `Copy` trait: this is the reason why you never see `clone()` used to copy numeric or boolean primitives.

But what happens if `=` is used with types who only have the `Clone` trait?

```rust
fn main() {
    let i: Vec<i32> = vec![1, 2, 3];
    let g = i; // something happens
    println!("{:?}", g);
    println!("{:?}", i); // error
}
```
The last `println!` throws an error at compile time:

![](/images/posts/borrow_me/bm_compile_error.png)

This is one of the first effects of the ownership/borrow system: the compiler says that we are trying to borrow `i` **after** we moved it. We will see later what this means.

### 4. The ampersand operator `&`

When used in front of variables, `&` references them, that is, it contains information to access the value in the memory. For example, `&String` has information
on where the `String` starts in memory, its length, and its capacity (aka maximum length possible):

```rust
fn main() {
    let mut i: String = String::with_capacity(15);
    let s = "I am a string";
    for c in s.chars() {
        i.push(c);       // fill String i
    }
    let t = &i;          // reference
    println!("Memory address: {:?}", t.as_ptr()); 
    println!("Length: {}", t.len());
    println!("Capacity: {}", t.capacity());
}
```

    Output:
    Memory address: 0x55d9c2f8fad0
    Length: 13
    Capacity: 15


## The ownership/borrow system

I find useful to break down the system into two different levels: the mental model and the implementation.
The mental model as three key concepts: ownership, actions and coherence.

### Ownership 
It means that an owner $$A$$ owns $$B$$, and that $$A$$ is the **sole responsible** of deciding what happens to $$B$$ and itself.
`let string = String::from("Hello")` means exactly that: `string` owns `Hello` and manages it.

### Actions
Let's say we have the owner $$A$$, the owned value $$B$$ and a third object $$C$$ yet to be defined.
What are the significant actions that $$A$$ applies on $$B$$ and itself, and how those reflect on another object $$C$$?
The table below gives an overview of the actions:

| Action | Applies to   | Affects |
| ------ | ------------ | ------- |
| read   | $$B$$        |         |
| write  | $$B$$        |         |
| copy   | $$B$$        | $$C$$   |
| clone  | $$B$$        | $$C$$   |
| move   | $$A$$, $$B$$ | $$C$$   |
| borrow | $$A$$, $$B$$ | $$C$$   |
| drop   | $$A$$, $$B$$ |         |

Most of the actions are obvious from the premises, and two are critical in Rust: move and borrow.

Move transfers ownership, meaning that a third object $$C$$ becomes the sole owner of $$B$$, and $$A$$ cannot be used anymore[^1]:

```rust
fn main() {
    let string = String::from("Hello");
    let other_string = string; // string does not hold any value anymore
    println!("{}", other_string); // this prints fine
    // println!("{}", string); // if commented out, compiler complains
}
```


Borrow grants temporal access: $$A$$ allows a third object $$C$$ to access $$B$$ while still keeping ownership. Borrow is created using the reference operator `&` and it ends when the object borrowing is dropped:

```rust
fn main() {
    let string = String::from("Hello");
    let other_string = &string; // other_string has access to string
    println!("{}", other_string); // this prints fine
    // println!("{}", string); // this too
}
// main() ended, borrow is dropped
```

### Coherence

At any moment in time, actions on $$A$$, $$B$$ and related objects must be coherent to each other such that the program's behavior is never undefined.

Examples:

- $$B$$ cannot be dropped while it is still borrowed: what should the program return, if you try to read it?
    ```rust
    fn main() {
    let string = String::from("Hello");
    
    let t = &string; // borrow
    
    drop(string); // string dropped, what value holds t?
    println!("{}", t); // ERROR: the reference t is not bound to s anymore
    }
    ```

- $$B$$ cannot be changed after and while borrowed: a change in $$B$$ might mean a new reference. What the old one would point to?
    ```rust
    fn main() {
    let mut vec = vec![1,2];
    
    let t = &vec;

    vec.push(5);
    println!("{:?}", t);
    }
    ```

For example, it makes sense that once out of scope, the owner $$A$$ drops $$B$$ and itself, thus releasing memory:

```rust
fn main() {
    let string = String::from("Hello");
    // nothing else happening
}
```

    MIR Output:

    // WARNING: This output format is intended for human consumers only
    // and is subject to change without notice. Knock yourself out.
    fn main() -> () {
        let mut _0: ();
        let _1: std::string::String;
        scope 1 {
            debug string => _1;
        }

        bb0: {
            _1 = <String as From<&str>>::from(const "Hello") -> [return: bb1, unwind continue];
        }

        bb1: {
            drop(_1) -> [return: bb2, unwind continue];
        }

        bb2: {
            return;
        }
    }

If we look at the MIR, an intermediate compile-time step[^2], we see that the variable `string`, identified as `_1`, is owned the string "Hello" in the `bb0` block and dropped in `bb1`, just before going out of scope.


In general, variables have ownership over values: in `let string = String::from("Hello")`, the variable `string` has ownership over the value `"Hello"`.\
But values can also have ownership over other values, for example in case of complex data structures: in `let vector = vec![vec![1, 2], vec![3, 4]]`, the variable `vector` owns values `vec![1, 2]` and `vec![3, 4]`; value `vec![1, 2]` owns values `1` and `2`; value `vec![3, 4]` owns values `3` and `4`

This can lead to effects that are, at first, surprising:

```rust
fn main() {
    let vector = vec![vec![1,2],vec![3,2]];
    let number = vector[0][0];
    println!("{}", vector[0][0]);
}
```
    Output:
    1

The variable `vector` does not have a `Copy` trait, and neither its vector elements. Why no error is thrown? Because `vector[0][0]` is an integer, and integers have the `Copy` trait.



[^1]: it actually becomes uninitialized. You can assign it any value matching its type.
[^2]: for more details, [see the MIR article on Rust Blog](https://blog.rust-lang.org/2016/04/19/MIR.html)

| Action | Applies to   | Operator/Method         |
| ------ | ------------ | ----------------------- |
| read   | $$B$$        | general_method()        |
| write  | $$B$$        | `mut`, general_method() |
| copy   | $$B$$        | `=`                     |
| clone  | $$B$$        | `=`, `clone()`          |
| move   | $$A$$, $$B$$ | `=`                     |
| borrow | $$A$$, $$B$$ | `&`                     |
| drop   | $$A$$, $$B$$ | automatic, `drop()`     |