---
layout:     post
title:      "A take on the Ownership-Borrow world of Rust ðŸ¦€"
date:       2024-04-10
summary:    A look into Rust ownership/borrow system
categories: rust memory swe systems
---

# Useful resources (to move under reference before publish)
- [https://smallcultfollowing.com/babysteps/blog/2014/05/13/focusing-on-ownership/](https://smallcultfollowing.com/babysteps/blog/2014/05/13/focusing-on-ownership/)
- [https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html](https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html)


# Intro

Few weeks ago I started learning Rust. It is a fascinating language and, coming from Python, its Ownership-Borrow framework was novel to me. So novel, I obsessed on it for some days - maybe a week, I admit - as I tried to crack it open and make it mine.
I think I partially succeded, also thanks to writing this post. And I hope it can help other people too!

## Essential concepts

There are some essential facts that are required to understand why and how Ownership works the way it does.

### 0. It's not only about memory safety

You have probably heard many times that the Ownership framework of Rust is at the core of its memory-safe feature. But it is much more. Ownership is also about control and clarity: you (must) decide how long data can be accessed, how they interact with each other and if external interfaces can change them, forcing you to reason about your software.

### 1. Variables are, by default, immutable
When binding a value to a variable, it cannot be changed anymore:
```rust
fn main(){
    let x: i36 = 10;
    x = 5; // ERROR
}
```
The `let` keyword binds `10` to `x` until it is in scope.
~~That's it. `let x = 10` makes `x` immutable and will always have value `10` (as long as it is in scope).~~

### 2. Variables can be made mutable with `mut`
The `mut` keyword tells the compiler that the value to a variable can be changed:
```rust
fn main(){
    let mut x = 10;
    x = 5; // OK
    x = 3; // also OK
}
```
The variable `x` can hold any 36-bit integer as long as it is in scope. 
 ~~`let mut x = 1` allows to change the value later in the code (as long as it is in scope).~~

### 3. Data types possess the `Clone` trait and (some of them) the `Copy` trait too

A trait is a functionality used to tell how a type should behave. `Clone` allows to _explicitly_ duplicate an object:

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i.clone(); // function defined in `Clone`
    println!("I am i: {}", i);
    println!("I am g:{}", g);
}
```
    Output:
    4.5
    4.5

Here `i` and `g` are two distinct instances of type `f32` containing the value `4.5`. **All** types have `Clone`.

`Copy` is a subtrait of `Clone` and allows to _implicitly_ duplicate an object using the assignment operator `=`:

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i; // the equal sign "activates" Copy
    println!("{}", g);
    println!("{}", i);
}
```
    Output:
    4.5
    4.5

Here `clone()` and the assignment operator `=` do the same thing as long as a type has the `Copy` trait too.
Numbers, characters and booleans possess the both traits. The same is true for arrays and tuples contaiting types with `Copy`: this is the reason why you never see `clone()` being used with them.

But what happens if `=` is used with types who only have `Clone`?

```rust
fn main() {
    let i: Vec<i32> = vec![1, 2, 3];
    let g = i; // something happens
    println!("{:?}", g);
    println!("{:?}", i); // ERROR
}
```
The last `println!` throws an error at compile time:

![](/images/posts/borrow_me/bm_compile_error.png)

This is one of the first effects of the ownership/borrow system: the compiler says that we are trying to borrow `i` **after** we moved it. We will see later what this means.

### 4. The ampersand operator `&`

When used in front of variables, `&` references them, that is, it provides information used to access the value in memory. For example, `&String` has information
on where the `String` starts in memory, its length, and its capacity (aka maximum length possible):

```rust
fn main() {
    let mut i: String = String::with_capacity(15);
    let s = "I am a string";
    for c in s.chars() {
        i.push(c);       // fill String i
    }
    let t = &i;          // &String, reference
    println!("Memory address: {:p}", t); 
    println!("Length: {}", t.len());
    println!("Capacity: {}", t.capacity());
}
```

    Output:
    Memory address: 0x55d9c2f8fad0
    Length: 13
    Capacity: 15


## The Ownership-Borrowing system

~~I find useful to break down the system into two different levels: the mental model and the implementation.~~
Ownership and Borrow can be considered points of view of Rust.
~~I find useful to separate the system into two subsystems: uniqueness and sharing~~
~~The mental model has four key concepts: access and ownership, actions and coherence.~~
In ownership, a variable is responsible of the value it is bound to: 

```rust
fn main(){
    let string = String::from("Hello");
    let number = 100;
}
```
The variables `string` and `number` have the **sole ownership** over their values, `Hello` and `100`, respectively. No one else can have access to them but their owners.

In borrowing, the owners **temporarily** surrender their ownership to others:

```rust

fn borrowing_string_and_number(b1: &String, b2: &i32){
    println!("{} World!", b1);
    println!("{} + 1: {}", b2, b2 + 1);
} 


fn main(){
    let string = String::from("Hello");
    let number = 100;

    // string and number surrender ownership
    borrowing_string_and_number(&string, &number); 
    // string and number have onwership back


}
```

### Unique access
In Rust, a variable can have exclusive access to a value:
Unique access means that a variable has exclusive access to a value.

### Ownership 
It means that an owner $$A$$ owns $$B$$, and that $$A$$ is the **sole responsible** of deciding what happens to $$B$$ and itself.
`let string = String::from("Hello")` means exactly that: `string` owns `Hello` and manages it.

### Actions
Let's say we have the owner $$A$$, the owned value $$B$$ and a third object $$C$$ yet to be defined.
What are the significant actions that $$A$$ applies on $$B$$ and itself, and how those reflect on another object $$C$$?
The table below gives an overview of the actions:

| Action | Applies to   | Affects |
| ------ | ------------ | ------- |
| read   | $$B$$        |         |
| write  | $$B$$        |         |
| copy   | $$B$$        | $$C$$   |
| clone  | $$B$$        | $$C$$   |
| move   | $$A$$, $$B$$ | $$C$$   |
| borrow | $$A$$, $$B$$ | $$C$$   |
| drop   | $$A$$, $$B$$ |         |


Most of the actions are obvious from the premises, and two are critical in Rust: move and borrow.

Move transfers ownership, meaning that a third object $$C$$ becomes the sole owner of $$B$$, and $$A$$ cannot be used anymore[^1]:

```rust
fn main() {
    let string = String::from("Hello");
    let other_string = string; // string does not hold any value anymore
    println!("{}", other_string); // this prints fine
    // println!("{}", string); // if commented out, compiler complains
}
```


Borrow grants temporal access: $$A$$ allows a third object $$C$$ to access $$B$$ while still keeping ownership. Borrow is created using the reference operator `&` and it ends when the object borrowing is dropped:

```rust
fn main() {
    let string = String::from("Hello");
    let other_string = &string; // other_string has access to string
    println!("{}", other_string); // this prints fine
    // println!("{}", string); // this too
}
// main() ended, borrow is dropped
```

### Coherence

At any moment in time, actions on $$A$$, $$B$$ and related objects must be coherent to each other such that the program's behavior is never undefined.

Examples:

- $$A$$ and $$B$$ cannot be dropped while $$B$$ is still borrowed: what should the program return, if you try to read it?
    ```rust
    fn main() {
    let string = String::from("Hello");
    
    let t = &string; // borrow
    
    drop(string); // string dropped, what value holds t?
    println!("{}", t); // undefined behavior for t
    }
    ```

- $$B$$ cannot be changed while borrowed: a change in $$B$$ generally changes its location in memory, aka the reference. What would the old reference point to?
    ```rust
    fn main() {
        let mut vec = vec![1,2];

        let t = &vec;
        println!("Before push: {:?}", t.as_ptr());

        for l in 0..100000 {
        vec.push(l);
        }

        println!("After push: {:?}", vec.as_ptr());
    }
    ```
        Output:
        Before: 0x561ac43289d0
        After: 0x7fa742183010

    Because `t` holds an old reference, it's undefined what it points to:
    ```rust
    fn main() {
        let mut vec = vec![1,2];

        let t = &vec;        // 0x561ac43289d0
        for l in 0..100000 {
        vec.push(l);
        }                    // 0x7fa742183010

        println!("{:?}", t); // t does not refer to vec anymore
    }
    ```

- $$B$$




For example, it makes sense that once out of scope, the owner $$A$$ drops $$B$$ and itself, thus releasing memory:

```rust
fn main() {
    let string = String::from("Hello");
    // nothing else happening
}
```

    MIR Output:

    // WARNING: This output format is intended for human consumers only
    // and is subject to change without notice. Knock yourself out.
    fn main() -> () {
        let mut _0: ();
        let _1: std::string::String;
        scope 1 {
            debug string => _1;
        }

        bb0: {
            _1 = <String as From<&str>>::from(const "Hello") -> [return: bb1, unwind continue];
        }

        bb1: {
            drop(_1) -> [return: bb2, unwind continue];
        }

        bb2: {
            return;
        }
    }

If we look at the MIR, an intermediate compile-time step[^2], we see that the variable `string`, identified as `_1`, is owned the string "Hello" in the `bb0` block and dropped in `bb1`, just before going out of scope.


In general, variables have ownership over values: in `let string = String::from("Hello")`, the variable `string` has ownership over the value `"Hello"`.\
But values can also have ownership over other values, for example in case of complex data structures: in `let vector = vec![vec![1, 2], vec![3, 4]]`, the variable `vector` owns values `vec![1, 2]` and `vec![3, 4]`; value `vec![1, 2]` owns values `1` and `2`; value `vec![3, 4]` owns values `3` and `4`

This can lead to effects that are, at first, surprising:

```rust
fn main() {
    let vector = vec![vec![1,2],vec![3,2]];
    let number = vector[0][0];
    println!("{}", vector[0][0]);
}
```
    Output:
    1

The variable `vector` does not have a `Copy` trait, and neither its vector elements. Why no error is thrown? Because `vector[0][0]` is an integer, and integers have the `Copy` trait.



[^1]: it actually becomes uninitialized. You can assign it any value matching its type.
[^2]: for more details, [see the MIR article on Rust Blog](https://blog.rust-lang.org/2016/04/19/MIR.html)

| Action | Applies to   | Operator/Method         |
| ------ | ------------ | ----------------------- |
| read   | $$B$$        | general_method()        |
| write  | $$B$$        | `mut`, general_method() |
| copy   | $$B$$        | `=`                     |
| clone  | $$B$$        | `=`, `clone()`          |
| move   | $$A$$, $$B$$ | `=`                     |
| borrow | $$A$$, $$B$$ | `&`                     |
| drop   | $$A$$, $$B$$ | automatic, `drop()`     |