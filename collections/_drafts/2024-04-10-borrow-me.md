---
layout:     post
title:      "Borrow me ðŸ¦€"
date:       2024-04-10
summary:    A look into Rust ownership/borrow system
categories: rust memory swe systems
---

I find the ownership/borrow system not so easily explained on the internet, so I wanted to give it a try.

Before to describe it, important premises must be done:

### Variables are, by default, immutable

Well, that's it. `let x = 1` makes `x` immutable and will always have value `1` as long as it's in scope.

### Variables can be made mutable

`let mut x = 1` allows to change the value later in the code as long as the variable is in scope.

### Data types possess the `Clone` trait and (sometimes) the `Copy` trait

The `Clone` trait is a functionality that allows to _explicitly_ duplicate an object.\
**All** data types have the `Clone` trait.

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i.clone(); // function defined in `Clone`
    println!("{}", g);
    println!("{}", i);
}
```
Here `i` and `g` are two distinct instances of type `f32` containing the value `4.5`.

The `Copy` trait is a functionality that allows to _implicitly_ duplicate an object.
Numbers, characters, booleans and tuples containing such data types possess the `Clone` and `Copy` traits.
By definition, `Copy` is a subtrait of `Clone`. What does this mean?

```rust
fn main() {
    let i: f32 = 4.5;
    let g = i; // the equal sign "activates" Copy
    println!("{}", g);
    println!("{}", i);
}
```

Here `clone()` and the assignment operator `=` do the same thing as long as a type has the `Copy` trait: you never see indeed use `clone()` for such types.\

### The ampersand operator `&`

When used in front of variables, `&` references them, that is, it contains information to find the value in the memory. For example, `&String` has information
on where the `String` starts in memory, its length, and its capacity:

```rust
fn main() {
    let mut i: String = String::with_capacity(15);
    let s = "I am a string";
    for c in s.chars() {
        i.push(c);       // fill String i
    }
    let t = &i;          // reference
    println!("Pointer: {:?}", t.as_ptr()); // memory address
    println!("Length: {}", t.len());
    println!("Capacity: {}", t.capacity());
}

Pointer: 0x55d9c2f8fad0
Length: 13
Capacity: 15
```


### Move vs. copy semantics



But what does happen if `=` is used with a type that has only `Clone`?

```rust
fn main() {
    let i: Vec<i32> = vec![1, 2, 3];
    let g = i; // something happens
    println!("{:?}", g);
    println!("{:?}", i); // error[E0382]: borrow of moved value: `i`
}
```
The error is due to how the ownership and borrow system works